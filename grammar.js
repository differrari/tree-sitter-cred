export default grammar({
  name: "cred",
  extras: ($) => [
    // NEWLINE,
    /\s/,
    $.comment,
  ],
  rules: {
    block: $ => prec(100,choice(seq($.statement, optional($.block)))),
		statement: $ => prec(99,choice(seq($.interface),seq($.enum),seq($.def),seq($.struct),seq($.include),seq($.dowhile, $.SEMICOLON),seq($.whileloop),seq($.conditional),seq($.switch),seq($.funcdec),seq($.LBRACE, optional($.block), $.RBRACE),seq($.forloop),seq($.jump, $.SEMICOLON),seq($.return, $.SEMICOLON),seq($.chain, $.SEMICOLON),seq($.assignment, $.SEMICOLON),seq($.declaration, $.SEMICOLON),seq($.label),seq($.funccall, $.SEMICOLON))),
		def: $ => prec(98,choice(seq("defer", $.statement))),
		include: $ => prec(97,choice(seq($.SYMBOL, "includeC", $.LPAREN, $.inc, $.RPAREN),seq($.SYMBOL, "include", $.inc))),
		separator: $ => prec(96,choice(seq($.SEMICOLON),seq($.NEWLINE))),
		assignment: $ => prec(95,choice(seq($.variable, $.OPERATOR, $.expression),seq($.chain, $.OPERATOR, $.expression))),
		funccall: $ => prec(94,choice(seq(optional("*"), optional("&"), $.func, $.LPAREN, optional($.argument), $.RPAREN))),
		funcdec: $ => prec(93,choice(seq(optional($.type), $.name, optional($.funcarguments), $.LBRACE, optional($.block), $.RBRACE))),
		funcsign: $ => prec(92,choice(seq(optional($.type), $.name, optional($.funcarguments)))),
		funcarguments: $ => prec(91,choice(seq($.LPAREN, optional($.argdec), $.RPAREN))),
		argdec: $ => prec(90,choice(seq($.type, $.name, $.COMMA, $.argdec),seq($.type, $.name))),
		argument: $ => prec(89,choice(seq(optional($.argname), $.expression, $.COMMA, $.argument),seq(optional($.argname), $.expression))),
		argname: $ => prec(88,choice(seq($.IDENTIFIER, $.COLON))),
		conditional: $ => prec(87,choice(seq("if", $.condition, $.LBRACE, optional($.block), $.RBRACE, optional($.else)))),
		else: $ => prec(86,choice(seq("else", $.LBRACE, optional($.block), $.RBRACE),seq("else", $.conditional))),
		condition: $ => prec(85,choice(seq($.LPAREN, $.expression, $.RPAREN),seq($.expression))),
		declaration: $ => prec(84,choice(seq($.type, $.COLON, $.subtype, optional("*"), $.name, $.OPERATOR, $.expression),seq($.type, optional("*"), $.name, $.OPERATOR, $.expression),seq($.type, optional($.COLON), optional($.subtype), optional("*"), $.name),seq($.type, optional("*"), $.name))),
		jump: $ => prec(83,choice(seq("goto", $.jmp))),
		label: $ => prec(82,choice(seq($.name, $.COLON))),
		expression: $ => prec(81,choice(seq("not", $.expression),seq($.LPAREN, $.expression, $.RPAREN),seq($.math),seq($.lambda),seq($.funccall),seq($.chain),seq($.val),seq($.variable))),
		lambda: $ => prec(80,choice(seq(optional($.type), $.LPAREN, $.argdec, $.RPAREN, $.LBRACE, optional($.block), $.RBRACE))),
		chain: $ => prec(79,choice(seq($.variable, $.op, $.funccall),seq($.variable, $.op, $.variable))),
		math: $ => prec(78,choice(seq($.funccall, $.OPERATOR, $.expression),seq($.val, $.OPERATOR, $.expression),seq($.variable, $.OPERATOR, $.expression))),
		variable: $ => prec(77,choice(seq(optional("*"), optional("&"), $.var, $.LBRACKET, $.expression, $.RBRACKET),seq(optional("*"), optional("&"), $.var))),
		forloop: $ => prec(76,choice(seq("for", $.LPAREN, $.declaration, $.SEMICOLON, $.condition, $.SEMICOLON, $.assignment, $.RPAREN, $.LBRACE, optional($.block), $.RBRACE))),
		whileloop: $ => prec(75,choice(seq("while", $.condition, $.LBRACE, optional($.block), $.RBRACE))),
		dowhile: $ => prec(74,choice(seq("do", $.LBRACE, optional($.block), $.RBRACE, "while", $.condition))),
		enum: $ => prec(73,choice(seq("enum", $.name, $.LBRACE, optional($.enumcase), $.RBRACE))),
		enumcase: $ => prec(72,choice(seq($.name, $.COMMA, optional($.enumcase)),seq($.name))),
		struct: $ => prec(71,choice(seq("struct", $.name, $.LBRACE, optional($.decblock), $.RBRACE),seq("struct", $.name, $.COLON, optional($.parent), $.LBRACE, optional($.decblock), $.RBRACE))),
		decblock: $ => prec(70,choice(seq($.declaration, $.SEMICOLON, optional($.decblock)),seq($.funcdec, optional($.decblock)))),
		return: $ => prec(69,choice(seq("return", optional($.expression)))),
		interface: $ => prec(68,choice(seq("interface", $.name, $.LBRACE, optional($.intblock), $.RBRACE))),
		intblock: $ => prec(67,choice(seq($.declaration, $.SEMICOLON, optional($.intblock)),seq($.funcsign, $.SEMICOLON, optional($.intblock)))),
		switch: $ => prec(66,choice(seq("switch", $.LPAREN, $.expression, $.RPAREN, $.LBRACE, optional($.switchbody), $.RBRACE),seq("switch", $.expression, $.LBRACE, optional($.switchbody), $.RBRACE))),
		switchbody: $ => prec(65,choice(seq(optional("case"), $.expression, $.COLON, $.LBRACE, optional($.block), $.RBRACE, optional($.switchbody)))),
		inc: $ => prec(64,choice(seq($.CONST))),
		func: $ => prec(63,choice(seq($.IDENTIFIER))),
		type: $ => prec(62,choice(seq($.IDENTIFIER))),
		name: $ => prec(61,choice(seq($.IDENTIFIER))),
		subtype: $ => prec(60,choice(seq($.IDENTIFIER))),
		jmp: $ => prec(59,choice(seq($.IDENTIFIER))),
		val: $ => prec(58,choice(seq($.CONST))),
		op: $ => prec(57,choice(seq($.DOT))),
		var: $ => prec(56,choice(seq($.IDENTIFIER))),
		parent: $ => prec(55,choice(seq($.IDENTIFIER))),
		literals: $ => prec(54,choice(seq("defer"),seq("includeC"),seq("include"),seq("if"),seq("else"),seq("goto"),seq("not"),seq("for"),seq("while"),seq("do"),seq("enum"),seq("struct"),seq("return"),seq("interface"),seq("switch"),seq("case"))),
		SYMBOL: $ => choice("#", "@"),
    SEMICOLON: $ => ";",
    RPAREN: $ => ")",
    LPAREN: $ => "(",
    NEWLINE: $ => "\n",
    CONST: $ => choice(new RustRegex('"[^"]*"'), new RustRegex("[0-9_]+")),
    IDENTIFIER: $ => new RustRegex('[a-z_][a-z0-9_]*'),
    OPERATOR: $ => choice(">>>", "<<=", ">>=", "===", "==", "!=", "<=", ">=", "&&", "||", "<<", ">>", "+=", "-=", "*=", "/=", "%=", "&=", "|=", "^=", "::", "->", "+", "-", "*", "/", "%", "=", "<",">","!","&","|","^","~","?"),
    COLON: $ => ":",
    RBRACE: $ => "}",
    LBRACE: $ => "{",
    RBRACKET: $ => "]",
    LBRACKET: $ => "[",
    COMMA: $ => ",",
    DOT: $ => ",",
    comment: ($) => token(prec(200, seq("//", /.*/))),
  },
});