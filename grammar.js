export default grammar({
	name: "cred",
  rules: {
    block: $ => prec(100,choice(seq($.statement, optional($.block)))),
		statement: $ => prec(99,choice(seq($.interface),seq($.enum),seq($.def),seq($.struct),seq($.include),seq($.dowhile, $.SEMICOLON),seq($.whileloop),seq($.conditional),seq($.switch),seq($.funcdec),seq($.LBRACE, optional($.block), $.RBRACE),seq($.forloop),seq($.jump, $.SEMICOLON),seq($.return, $.SEMICOLON),seq($.chain, $.SEMICOLON),seq($.assignment, $.SEMICOLON),seq($.declaration, $.SEMICOLON),seq($.label),seq($.funccall, $.SEMICOLON))),
		def: $ => prec(98,choice(seq("defer", $.statement))),
		include: $ => prec(97,choice(seq($.SYMBOL, "includeC", $.LPAREN, $.CONST, $.RPAREN),seq($.SYMBOL, "include", $.CONST))),
		separator: $ => prec(96,choice(seq($.SEMICOLON),seq($.NEWLINE))),
		assignment: $ => prec(95,choice(seq($.variable, $.OPERATOR, $.expression),seq($.chain, $.OPERATOR, $.expression))),
		funccall: $ => prec(94,choice(seq(optional("*"), optional("&"), $.IDENTIFIER, $.LPAREN, optional($.argument), $.RPAREN))),
		funcdec: $ => prec(93,choice(seq(optional($.IDENTIFIER), $.IDENTIFIER, optional($.funcarguments), $.LBRACE, optional($.block), $.RBRACE))),
		funcsign: $ => prec(92,choice(seq(optional($.IDENTIFIER), $.IDENTIFIER, optional($.funcarguments)))),
		funcarguments: $ => prec(91,choice(seq($.LPAREN, optional($.argdec), $.RPAREN))),
		argdec: $ => prec(90,choice(seq($.IDENTIFIER, $.IDENTIFIER, $.COMMA, $.argdec),seq($.IDENTIFIER, $.IDENTIFIER))),
		argument: $ => prec(89,choice(seq(optional($.argname), $.expression, $.COMMA, $.argument),seq(optional($.argname), $.expression))),
		argname: $ => prec(88,choice(seq($.IDENTIFIER, $.COLON))),
		conditional: $ => prec(87,choice(seq("if", $.condition, $.LBRACE, optional($.block), $.RBRACE, optional($.else)))),
		else: $ => prec(86,choice(seq("else", $.LBRACE, optional($.block), $.RBRACE),seq("else", $.conditional))),
		condition: $ => prec(85,choice(seq($.LPAREN, $.expression, $.RPAREN),seq($.expression))),
		declaration: $ => prec(84,choice(seq($.IDENTIFIER, $.COLON, $.IDENTIFIER, optional("*"), $.IDENTIFIER, $.OPERATOR, $.expression),seq($.IDENTIFIER, optional("*"), $.IDENTIFIER, $.OPERATOR, $.expression),seq($.IDENTIFIER, optional($.COLON), optional($.IDENTIFIER), optional("*"), $.IDENTIFIER),seq($.IDENTIFIER, optional("*"), $.IDENTIFIER))),
		jump: $ => prec(83,choice(seq("goto", $.IDENTIFIER))),
		label: $ => prec(82,choice(seq($.IDENTIFIER, $.COLON))),
		expression: $ => prec(81,choice(seq("not", $.expression),seq($.LPAREN, $.expression, $.RPAREN),seq($.math),seq($.lambda),seq($.funccall),seq($.chain),seq($.CONST),seq($.variable))),
		lambda: $ => prec(80,choice(seq(optional($.IDENTIFIER), $.LPAREN, $.argdec, $.RPAREN, $.LBRACE, optional($.block), $.RBRACE))),
		chain: $ => prec(79,choice(seq($.variable, $.DOT, $.funccall),seq($.variable, $.DOT, $.variable))),
		math: $ => prec(78,choice(seq($.funccall, $.OPERATOR, $.expression),seq($.CONST, $.OPERATOR, $.expression),seq($.variable, $.OPERATOR, $.expression))),
		variable: $ => prec(77,choice(seq(optional("*"), optional("&"), $.IDENTIFIER, $.LBRACKET, $.expression, $.RBRACKET),seq(optional("*"), optional("&"), $.IDENTIFIER))),
		forloop: $ => prec(76,choice(seq("for", $.LPAREN, $.declaration, $.SEMICOLON, $.condition, $.SEMICOLON, $.assignment, $.RPAREN, $.LBRACE, optional($.block), $.RBRACE))),
		whileloop: $ => prec(75,choice(seq("while", $.condition, $.LBRACE, optional($.block), $.RBRACE))),
		dowhile: $ => prec(74,choice(seq("do", $.LBRACE, optional($.block), $.RBRACE, "while", $.condition))),
		enum: $ => prec(73,choice(seq("enum", $.IDENTIFIER, $.LBRACE, optional($.enumcase), $.RBRACE))),
		enumcase: $ => prec(72,choice(seq($.IDENTIFIER, $.COMMA, optional($.enumcase)),seq($.IDENTIFIER))),
		struct: $ => prec(71,choice(seq("struct", $.IDENTIFIER, $.LBRACE, optional($.decblock), $.RBRACE),seq("struct", $.IDENTIFIER, $.COLON, optional($.IDENTIFIER), $.LBRACE, optional($.decblock), $.RBRACE))),
		decblock: $ => prec(70,choice(seq($.declaration, $.SEMICOLON, optional($.decblock)),seq($.funcdec, optional($.decblock)))),
		return: $ => prec(69,choice(seq("return", optional($.expression)))),
		interface: $ => prec(68,choice(seq("interface", $.IDENTIFIER, $.LBRACE, optional($.intblock), $.RBRACE))),
		intblock: $ => prec(67,choice(seq($.declaration, $.SEMICOLON, optional($.intblock)),seq($.funcsign, $.SEMICOLON, optional($.intblock)))),
		switch: $ => prec(66,choice(seq("switch", $.LPAREN, $.expression, $.RPAREN, $.LBRACE, optional($.switchbody), $.RBRACE),seq("switch", $.expression, $.LBRACE, optional($.switchbody), $.RBRACE))),
		switchbody: $ => prec(65,choice(seq(optional("case"), $.expression, $.COLON, $.LBRACE, optional($.block), $.RBRACE, optional($.switchbody)))),SYMBOL: $ => choice("#","@"),
    SYMBOL: $ => choice("#","@"),
    SEMICOLON: $ => ";",
    RPAREN: $ => ")",
    LPAREN: $ => "(",
    NEWLINE: $ => "\n",
    CONST: $ => choice(new RustRegex('"[^"]*"'), new RustRegex("[0-9_]+")),
    IDENTIFIER: $ => new RustRegex('[a-z_][a-z0-9_]*'),
    OPERATOR: $ => choice(">>>", "<<=", ">>=", "===", "==", "!=", "<=", ">=", "&&", "||", "<<", ">>", "+=", "-=", "*=", "/=", "%=", "&=", "|=", "^=", "::", "->", "+", "-", "*", "/", "%", "=", "<",">","!","&","|","^","~","?"),
    COLON: $ => ":",
    RBRACE: $ => "}",
    LBRACE: $ => "{",
    RBRACKET: $ => "]",
    LBRACKET: $ => "[",
    COMMA: $ => ",",
    DOT: $ => ",",
  },
});